#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    leftLineFollower, sensorLineFollower)
#pragma config(Sensor, in2,    centerLineFollower, sensorLineFollower)
#pragma config(Sensor, in3,    rightLineFollower, sensorLineFollower)
#pragma config(Sensor, in6,    gyro,           sensorGyro)
#pragma config(Sensor, in8,    potentiometer,  sensorPotentiometer)
#pragma config(Sensor, dgtl1,  rightEncoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  leftEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl6,  touchSensor,    sensorTouch)
#pragma config(Sensor, dgtl8,  sonarSensor,    sensorSONAR_cm)
#pragma config(Sensor, dgtl11, armEncoder,     sensorQuadEncoder)
#pragma config(Sensor, I2C_1,  rightIME,       sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  leftIME,        sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_3,  armIME,         sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           leftMotor,     tmotorVex393_HBridge, openLoop, reversed, driveLeft, encoderPort, I2C_2)
#pragma config(Motor,  port6,           clawMotor,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           armMotor,      tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_3)
#pragma config(Motor,  port10,          rightMotor,    tmotorVex393_HBridge, openLoop, driveRight, encoderPort, I2C_1)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
Name: Gino Ako
Date: 10/09/17
Class: Robotics I
Task:Complete obsticle course
/////////////////////////////////
Description:
Have bot forward to object, move object out of way, go straight
and begin to follow black line. Once done folowing go straight a bit
and bump wall. After bumping have bot turn right and swivl thru the two
post and then follow green line to the finsh line and raise arm to touch
flag to finsh the course.



Pseudocode:
0. Bump start
1. Move Forward
2. Stop In front of target with Sonar
3. Open Claw
4. Move forward
5. close claw
6. move arm up w/ wait time
7. open claw
8. arm down
9. move forward
10.move with Line Tracking
11.until bump
12. stop
13. reverse
14. point turn
15. forward



*/
///////////////////Foward Until Encoder////////////////////
void fue()
{//start
	while(SensorValue[rightEncoder]<2000)
	{//while
		motor[rightMotor]=64;
		motor[leftMotor]=64;
	}//while
}//close
///////////////////Foward Command//////////////////////////
/*
void fwd()
{
motor[rightMotor]=64;
motor[leftMotor]=64;
}
*/
///////////////////Open Claw////////////////
void oc()
{
	motor[clawMotor]=64;
	wait(1.0);
	motor[clawMotor]=0;
}
///////////////////Close Claw//////////////
void cc()
{
	motor[clawMotor]=-64;
}
//////////////////arm Up/////////////////
void au()
{
	motor[armMotor]=64;
	wait(2.0);
	motor[armMotor]=-64;
}
///////////////Arm down////////////////
void ad()
{
	motor[armMotor]=-64;
	wait(2.0);
	motor[armMotor]=0;
}
///////////////////Auto Straight Code//////////////////////////
void as()
{
	while(SensorValue[rightEncoder] < 2050)
	{//Open While Loop
		(SensorValue[leftEncoder] = 0);///////////////////Auto Straight Code//////////////////////////
		//1. If left encoder > right encoder, slow left motor
		if(SensorValue[leftEncoder] > SensorValue[rightEncoder])
		{
			motor[rightMotor]=96; //left correction
			motor[leftMotor]=80;
		}
		//2. If right encoder > left encoder, slow right motor
		if(SensorValue[rightEncoder] > SensorValue[leftEncoder])
		{
			motor[rightMotor]=80; //right correction
			motor[leftMotor]=96;
		}
		//3. If right & left encoder is =, do nothing
		if(SensorValue[rightEncoder]== SensorValue[leftEncoder])
		{
			motor[rightMotor]=96; // No correction
			motor[leftMotor]=96;
		}	 //Close If
	}/// Closes While
}	//Close
///////////////////Stop Robot////////////////
void pause()
{
	motor[rightMotor]=0;
	motor[leftMotor]=0;
}
///////////////////Bump/////////////////////
void bump()
{
	untilBump(dgtl6,500);
}
///////////////////Reverse////////////////
void gearR()
{
	motor[leftMotor]=-64;
	motor[rightMotor]=-64;
}
///////////////////Point Turn Right//////////////
void ptr()
{
	motor[rightMotor]=-64;
	motor[leftMotor]=64;
}
////////////////Line Tracker////////////////////
void lt()
{
	{
		int threshold;
		threshold = 2400;

		int speed;
		speed = 40;

		int correct;
		correct = -35;
		///////////////////////
		while(1==1)
		{
			////center dark = straight
			if(SensorValue[centerLineFollower]>threshold)
			{
				motor[rightMotor]=speed;
				motor[leftMotor]=speed;
			}
			////left dark = correct to left
			if(SensorValue[leftLineFollower]>threshold)
			{
				motor[rightMotor]=speed;
				motor[leftMotor]=correct;
			}
			////right dark = correct to right
			if(SensorValue[rightLineFollower]>threshold)
			{
				motor[rightMotor]=correct;
				motor[leftMotor]=speed;
			}
		}//close loop
	}//close task
}
////////////////////////////////////////
////////////////////////////////////////
////////////////////////////////////////
////////////////////////////////////////
/////////////Task main//////////////////
task main()
{
	/////Push to Start Whip////
	untilBump(dgtl6, 500);
	//Open Claw
	motor[clawMotor]=80;
	//Move Until Sonar//
	while(SensorValue[sonarSensor]>16)
	{
		as();
	}
	////Open Claw////
	{
		oc();
	}
	////Close Claw///
	{
		cc();
	}
	////arm up////
	{
		au();
	}
	////open claw////
	{
		oc();
	}
	////close claw//
	{
		cc();
	}
	////arm down///
	{
		ad();
	}
	////Foward until Encoder////
	{
		fue();
	}
	////Line Tracking////
	{
		lt();
	}
	////Until Bump////
	bump();
	////Stop///
	{
		pause();
	}
	////reverse////
	{
		gearR();
	}
	////point turn right/////////
	{
		ptr();
	}
}
